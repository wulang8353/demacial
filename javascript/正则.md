## 正则表达式

[正则表达式快速参考MDN](https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)

[正则表达式30分钟入门](http://deerchao.net/tutorials/regex/regex.htm)

* [简述](#简述)
 * [单词匹配](#单词匹配)
 * [工整匹配](#工整匹配)
 * [分支条件](#分支条件)
 * [分组-多字符匹配](#分组-多字符匹配)
 * [反向引用](#反向引用)
 * [零宽断言](#零宽断言)
 * [负零宽断言](#负零宽断言)
 * [贪婪和懒惰](#贪婪和懒惰)



## 字符集快速查找

- 常用元字符

| 代码       | 说明  |
| --------  | -----|
| .         |  匹配除换行符以外的任意字符|
| \w        |  匹配字母或数字或下划线或汉字|
| \d        |	匹配数字|
| \s        |	匹配任意的空白符|
| \b        |	匹配单词的开始或结束|
| ^         |	匹配字符串的开始|
| \$        |	匹配字符串的结束|


- 反义代码

| 代码       | 说明  |
| --------  | -----|
| \W        |  匹配任意不是字母，数字，下划线，汉字的字符|
| \D        |	匹配任意非数字的字符|
| \S        |	匹配任意不是空白符的字符|
| \B        |	匹配不是单词的开始或结束|
| [^x]      |	匹配除了x以外的任意字符|
| [^aeiou]  |	匹配除了aeiou这几个字母以外的任意字符|

- 常用限定符

| 代码      | 说明  |
| --------  | -----|
| *         |  重复零次或更多次|
| +         |  重复一次或更多次|
| ?         |	重复零次或一次|
| {n}       |	重复n次|
| {n,}      |	重复n次或更多次|
| {n,m}     |	重复n到m次|

- 分组语法

| 分类       | 代码      | 说明  | 
| --------  | ----   |  ------ |
| 捕获       | (exp)        |  匹配exp,并捕获文本到自动命名的组里 |
| ~         |  (?<name>exp) |  匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |     
| ~         |	(?:exp)      |  匹配exp,不捕获匹配的文本，也不给此分组分配组号 |
| 零宽断言   |  (?=exp)      |	匹配exp前面的位置 |
| ~         |	(?<=exp)     |  匹配exp后面的位置 |
| ~         |	?!exp)       |  匹配后面跟的不是exp的位置 |
| ~         |	(?<!exp)     |   匹配前面不是exp的位置|

- 懒惰限定符

| 代码      | 说明  |
| --------  | -----|
| *?         |  重复零次或更多次,但尽可能少重复|
| +?         |  重复一次或更多次,但尽可能少重复|
| ??         |	重复零次或一次,但尽可能少重复|
| {n}?       |	重复n次,但尽可能少重复|
| {n,}?      |	重复n次或更多次,但尽可能少重复|
| {n,m}?     |	重复n到m次,但尽可能少重复|



## 简述

### 单词匹配 

- 匹配单词，类似 `hi-mylover-Lucy`

`\b` ：精确查找某个固定单词，代表着单词的开头和结尾，也就是单词的分界处，类似`\bhi\b`，并且不会匹配单词之间用来分隔的空格、标点符号或者换行

`.`  ： 匹配除了换行符意外的任意字符

`*`  ： 指定之前的内容可以连续重复任意次

`\s` ： 匹配任意的空白符（空格）

`\w` ： 匹配数字或者下划线或者汉字符

**例子**：

`/\bhi\b.*\bLucy\b/` ： `.*`任意数量的不包含换行的字符，先是hi这个单词，然后中间是任意不换行字符，最后遇到Lucy这个单词 

`/\ba\w*\b/` ： 匹配以字母a的单词开头，然后任意数量的数字或者字符，最后单词结束 `an2n1n`

`/\b\w{6}\b/` ： 匹配刚好有6个字符的单词

### 工整匹配

- 匹配字符串，类似 `022-12125214`


`^` ： 匹配字符串开始

`$` ： 匹配字符串结束

字符转义——针对元字符本身的使用需要转义

`.` 和 `*`  若要匹配这两个字符必须先转义，也就是说形式得是  `\.` 和`\*`

`[aeiou]` 匹配任意一个英文原因字符   `[.?!]` 匹配任意一个标点符号

`[0-9]`等同于`\d`    `[a-z0-9A-Z]` 等同于 `\w`

**例子**：

`/^\d{5,12}$/` 匹配的字符串刚好要是5到12个数字，也就是说，工整匹配
 
`/\(?0\d{2}[) -]?\d{8}/` 首先转义字符`\(`出现0次或1次，然后是一个数字0，紧接着是两个任意数字，随后匹配`) -`匹配这三个符号中任意一个而且0次或1次，最后是8个数字  如 022-12125214
  
### 分支条件

- 满足任意其中一种规则都能匹配，  `A 或者 B`

`0\d{2}-\d{8}|0\d{3}-\d{7}` ： 匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)

`/\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}/` ：匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔

`/\d{5}-\d{4}|\d{5}/`  ： 可以匹配9位数字或者5位数字
`/\d{5}|\d{5}-\d{4}/`  ： 可以匹配5位数字或者9位数字 

但是分支匹配是从左到右的测试每个条件，也就是说如果满足第一个就不会测试第二个了，如果想尽可能多的匹配就应该用第一种

### 分组-多字符匹配

- 单字符匹配使用`{n}`,多字符匹配使用分组，` 255.255.255.255`

`/(\d{1,3}\.){3}\d{1,3}/` ： 简单的IP地址匹配，`\d{1,3}\.` 表示有1到3位的数字后跟上一个符号 `.`，然后用`()`括起来，这就表示一个分组，然后这个分组重复三次`{3}`，最后加上一个1个到3个的数字`{1,3}`

但是可能匹配到不存在的地址，如999.888.777.0，因为地址中每个数字不能大于255

`/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/` 

`2[0-4]\d|25[0-5]|[01]?\d\d?` ：首先数字2，然后从0-4中去某个数字，随后一个数字  或者  数字25后匹配0-5中恩义某个数字 或者 0-1某个数字，出现0次或者1次，随后一个数字，再一个出现0次或者1次的数字

`(2[0-4]\d|25[0-5]|[01]?\d\d?)\.` ： 转移符号`.`

`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}` ： 上述规则出现三次，类似255.255.255

`(2[0-4]\d|25[0-5]|[01]?\d\d?)` ： 最后匹配一个具有第一个规则的数字即可

### 后向引用 

- 重复搜索前面某个分组匹配的文本   `Do you know i love you very very much`

- 从左向右，以分组的左括号为标志，第一个出现的左括号的为第一组，以此类推

`/\b(\w+)\b\s+\1\b/` ： 首先是一个单词，单词中有多于一个的字母或数字`(\b(\w+)\b)`，这个单词规则会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词规则需要加上\b）(\1)。

自定义组名，语法：`(?<Word>\w+)`或者把尖括号换成'也行：`(?'Word'\w+))`,这样就把`\w+`的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`

### 零宽断言 

- 查找某个规则之前或者之后的内容  `Do you konw i love 浙江工业大学` 匹配`daxue`以前的字符，即浙江工业

`(?=exp)`  ： 零宽度正预测**先行**断言，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找`I'm singing while you're dancing`.时，它会匹配sing和danc。同样的，`\b\w+(?=d大学\b)`会得到`浙江工业`

`(?<=exp)` ： 零宽度正回顾**后发**断言，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找`reading a book`时，它匹配ading。

同时使用了这两种断言：`(?<=\s)\d+(?=\s)` 匹配以空白符间隔的数字(再次强调，**不包括这些空白符**)

### 负零宽断言 

- 通过反义`^`字符类可以得到不是某个字符的方法

- 负零宽先行断言`(?!exp）` 断言此位置的后面不能匹配表达式exp，例如，某个单词出出现了字母q，但是q后面不要跟着字母u

- 负零宽后发断言`(?<!exp)` 断言来断言此位置的前面不能匹配表达式exp

`\b\w*q[^u]\w*\b`  ： 即可满足要求，但是如果q出现在单词的结尾的话，像`Iraq,uBenq`，应该成功却匹配失败。这是因为`[^u]`总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的`[^u]`总将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，所以既然能够匹配表达式，所以没有结果

`\b\w*q(?!u)\w*\b` ： 负零宽断言只匹配一个位置，不会消费任何字符，也就说`Iraq,uBenq`因为q后面，不再匹配符号`,`,也就是说不满足匹配条件，所以 得到`Iraq`和`uBenq`

**例子**：

`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字   `332w8`得到`332`，`3322w80`得到 `322`

`\b((?!abc)\w)+\b` 匹配开头不包含连续字符串abc的单词

`(?<![a-z])\d{7}`  匹配前面不是小写字母的七位数字

表达式`(?<=<(\w+)>).*(?=<\/\1>)`，匹配不包含属性的简单HTML标签内里的内容。

`(?<=<(\w+)>)`：类似单词`<b>`,，然后是`.*`(任意的非空白字符串),最后是一个后缀`(?=<\/\1>)`。注意后缀里的`\/`，它用到了前面提过的字符转义；`\1`则是一个反向引用，引用的正是捕获的第一组——前面的(\w+)匹配的内容，这样如果前缀实际上是`<b>`的话，后缀就是<`/b>`了。整个表达式匹配的是`<b>`和`</b>`之间的内容(**再次提醒，不包括前缀和后缀本身**)。

### 贪婪和懒惰

- 贪婪：表达式能得到匹配的前提上，尽可能的多匹配

- 懒惰：表达式能得到匹配的前提上，尽可能的多匹配，在字符集后加`?`

贪婪匹配：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索`aabab`的话，它会匹配整个字符串aabab。

懒惰匹配：`a.*?b`,匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样`.*?`就意味着匹配任意数量的重复。如果把它应用于`aabab`的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。

